/// Generated by the Protocol Buffers 3.5.1 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "package.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct PackageRoot {
    public static let `default` = PackageRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Track : GeneratedMessage {
    public typealias BuilderType = Track.Builder

    public static func == (lhs: Track, rhs: Track) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
        fieldCheck = fieldCheck && (lhs.hasAcc == rhs.hasAcc) && (!lhs.hasAcc || lhs.acc == rhs.acc)
        fieldCheck = fieldCheck && (lhs.hasNameApp == rhs.hasNameApp) && (!lhs.hasNameApp || lhs.nameApp == rhs.nameApp)
        fieldCheck = fieldCheck && (lhs.hasDeviceIp == rhs.hasDeviceIp) && (!lhs.hasDeviceIp || lhs.deviceIp == rhs.deviceIp)
        fieldCheck = fieldCheck && (lhs.pageViews == rhs.pageViews)
        fieldCheck = fieldCheck && (lhs.hasTypeConnection == rhs.hasTypeConnection) && (!lhs.hasTypeConnection || lhs.typeConnection == rhs.typeConnection)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var userId:String! = nil
    public fileprivate(set) var hasUserId:Bool = false

    public fileprivate(set) var acc:UInt32! = nil
    public fileprivate(set) var hasAcc:Bool = false

    public fileprivate(set) var nameApp:String! = nil
    public fileprivate(set) var hasNameApp:Bool = false

    public fileprivate(set) var deviceIp:String! = nil
    public fileprivate(set) var hasDeviceIp:Bool = false

    public fileprivate(set) var pageViews:Array<PageView>  = Array<PageView>()
    public fileprivate(set) var typeConnection:String! = nil
    public fileprivate(set) var hasTypeConnection:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasUserId {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(Track.self): field \"userId\" mark required")
        }
        if !hasAcc {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(Track.self): field \"acc\" mark required")
        }
        if !hasNameApp {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(Track.self): field \"nameApp\" mark required")
        }
        if !hasDeviceIp {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(Track.self): field \"deviceIp\" mark required")
        }
        for oneElementPageViews in pageViews {
            try oneElementPageViews.isInitialized()
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUserId {
            try codedOutputStream.writeString(fieldNumber: 1, value:userId)
        }
        if hasAcc {
            try codedOutputStream.writeUInt32(fieldNumber: 2, value:acc)
        }
        if hasNameApp {
            try codedOutputStream.writeString(fieldNumber: 3, value:nameApp)
        }
        if hasDeviceIp {
            try codedOutputStream.writeString(fieldNumber: 4, value:deviceIp)
        }
        for oneElementPageViews in pageViews {
              try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementPageViews)
        }
        if hasTypeConnection {
            try codedOutputStream.writeString(fieldNumber: 6, value:typeConnection)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUserId {
            serialize_size += userId.computeStringSize(fieldNumber: 1)
        }
        if hasAcc {
            serialize_size += acc.computeUInt32Size(fieldNumber: 2)
        }
        if hasNameApp {
            serialize_size += nameApp.computeStringSize(fieldNumber: 3)
        }
        if hasDeviceIp {
            serialize_size += deviceIp.computeStringSize(fieldNumber: 4)
        }
        for oneElementPageViews in pageViews {
            serialize_size += oneElementPageViews.computeMessageSize(fieldNumber: 5)
        }
        if hasTypeConnection {
            serialize_size += typeConnection.computeStringSize(fieldNumber: 6)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Track.Builder {
        return Track.classBuilder() as! Track.Builder
    }
    public func getBuilder() -> Track.Builder {
        return classBuilder() as! Track.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Track.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Track.Builder()
    }
    public func toBuilder() throws -> Track.Builder {
        return try Track.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Track) throws -> Track.Builder {
        return try Track.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUserId {
            jsonMap["userId"] = userId
        }
        if hasAcc {
            jsonMap["acc"] = UInt(acc)
        }
        if hasNameApp {
            jsonMap["nameApp"] = nameApp
        }
        if hasDeviceIp {
            jsonMap["deviceIP"] = deviceIp
        }
        if !pageViews.isEmpty {
            var jsonArrayPageViews:Array<Dictionary<String,Any>> = []
            for oneValuePageViews in pageViews {
                let ecodedMessagePageViews = try oneValuePageViews.encode()
                jsonArrayPageViews.append(ecodedMessagePageViews)
            }
            jsonMap["pageViews"] = jsonArrayPageViews
        }
        if hasTypeConnection {
            jsonMap["typeConnection"] = typeConnection
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Track {
        return try Track.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Track {
        return try Track.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUserId {
            output += "\(indent) userId: \(userId) \n"
        }
        if hasAcc {
            output += "\(indent) acc: \(acc) \n"
        }
        if hasNameApp {
            output += "\(indent) nameApp: \(nameApp) \n"
        }
        if hasDeviceIp {
            output += "\(indent) deviceIp: \(deviceIp) \n"
        }
        var pageViewsElementIndex:Int = 0
        for oneElementPageViews in pageViews {
            output += "\(indent) pageViews[\(pageViewsElementIndex)] {\n"
            output += try oneElementPageViews.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            pageViewsElementIndex += 1
        }
        if hasTypeConnection {
            output += "\(indent) typeConnection: \(typeConnection) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUserId {
                hashCode = (hashCode &* 31) &+ userId.hashValue
            }
            if hasAcc {
                hashCode = (hashCode &* 31) &+ acc.hashValue
            }
            if hasNameApp {
                hashCode = (hashCode &* 31) &+ nameApp.hashValue
            }
            if hasDeviceIp {
                hashCode = (hashCode &* 31) &+ deviceIp.hashValue
            }
            for oneElementPageViews in pageViews {
                hashCode = (hashCode &* 31) &+ oneElementPageViews.hashValue
            }
            if hasTypeConnection {
                hashCode = (hashCode &* 31) &+ typeConnection.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Track"
    }
    override public func className() -> String {
        return "Track"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Track = Track()
        public func getMessage() -> Track {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var userId:String {
            get {
                return builderResult.userId
            }
            set (value) {
                builderResult.hasUserId = true
                builderResult.userId = value
            }
        }
        public var hasUserId:Bool {
            get {
                return builderResult.hasUserId
            }
        }
        @discardableResult
        public func setUserId(_ value:String) -> Track.Builder {
            self.userId = value
            return self
        }
        @discardableResult
        public func clearUserId() -> Track.Builder{
            builderResult.hasUserId = false
            builderResult.userId = nil
            return self
        }
        public var acc:UInt32 {
            get {
                return builderResult.acc
            }
            set (value) {
                builderResult.hasAcc = true
                builderResult.acc = value
            }
        }
        public var hasAcc:Bool {
            get {
                return builderResult.hasAcc
            }
        }
        @discardableResult
        public func setAcc(_ value:UInt32) -> Track.Builder {
            self.acc = value
            return self
        }
        @discardableResult
        public func clearAcc() -> Track.Builder{
            builderResult.hasAcc = false
            builderResult.acc = nil
            return self
        }
        public var nameApp:String {
            get {
                return builderResult.nameApp
            }
            set (value) {
                builderResult.hasNameApp = true
                builderResult.nameApp = value
            }
        }
        public var hasNameApp:Bool {
            get {
                return builderResult.hasNameApp
            }
        }
        @discardableResult
        public func setNameApp(_ value:String) -> Track.Builder {
            self.nameApp = value
            return self
        }
        @discardableResult
        public func clearNameApp() -> Track.Builder{
            builderResult.hasNameApp = false
            builderResult.nameApp = nil
            return self
        }
        public var deviceIp:String {
            get {
                return builderResult.deviceIp
            }
            set (value) {
                builderResult.hasDeviceIp = true
                builderResult.deviceIp = value
            }
        }
        public var hasDeviceIp:Bool {
            get {
                return builderResult.hasDeviceIp
            }
        }
        @discardableResult
        public func setDeviceIp(_ value:String) -> Track.Builder {
            self.deviceIp = value
            return self
        }
        @discardableResult
        public func clearDeviceIp() -> Track.Builder{
            builderResult.hasDeviceIp = false
            builderResult.deviceIp = nil
            return self
        }
        public var pageViews:Array<PageView> {
            get {
                return builderResult.pageViews
            }
            set (value) {
                builderResult.pageViews = value
            }
        }
        @discardableResult
        public func setPageViews(_ value:Array<PageView>) -> Track.Builder {
            self.pageViews = value
            return self
        }
        @discardableResult
        public func clearPageViews() -> Track.Builder {
            builderResult.pageViews.removeAll(keepingCapacity: false)
            return self
        }
        public var typeConnection:String {
            get {
                return builderResult.typeConnection
            }
            set (value) {
                builderResult.hasTypeConnection = true
                builderResult.typeConnection = value
            }
        }
        public var hasTypeConnection:Bool {
            get {
                return builderResult.hasTypeConnection
            }
        }
        @discardableResult
        public func setTypeConnection(_ value:String) -> Track.Builder {
            self.typeConnection = value
            return self
        }
        @discardableResult
        public func clearTypeConnection() -> Track.Builder{
            builderResult.hasTypeConnection = false
            builderResult.typeConnection = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Track.Builder {
            builderResult = Track()
            return self
        }
        override public func clone() throws -> Track.Builder {
            return try Track.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Track {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Track {
            let returnMe:Track = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Track) throws -> Track.Builder {
            if other == Track() {
                return self
            }
            if other.hasUserId {
                userId = other.userId
            }
            if other.hasAcc {
                acc = other.acc
            }
            if other.hasNameApp {
                nameApp = other.nameApp
            }
            if other.hasDeviceIp {
                deviceIp = other.deviceIp
            }
            if !other.pageViews.isEmpty  {
                 builderResult.pageViews += other.pageViews
            }
            if other.hasTypeConnection {
                typeConnection = other.typeConnection
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Track.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Track.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    userId = try codedInputStream.readString()

                case 16:
                    acc = try codedInputStream.readUInt32()

                case 26:
                    nameApp = try codedInputStream.readString()

                case 34:
                    deviceIp = try codedInputStream.readString()

                case 42:
                    let subBuilder = PageView.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    pageViews.append(subBuilder.buildPartial())

                case 50:
                    typeConnection = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Track.Builder {
            let resultDecodedBuilder = Track.Builder()
            if let jsonValueUserId = jsonMap["userId"] as? String {
                resultDecodedBuilder.userId = jsonValueUserId
            }
            if let jsonValueAcc = jsonMap["acc"] as? UInt {
                resultDecodedBuilder.acc = UInt32(jsonValueAcc)
            } else if let jsonValueAcc = jsonMap["acc"] as? String {
                resultDecodedBuilder.acc = UInt32(jsonValueAcc)!
            }
            if let jsonValueNameApp = jsonMap["nameApp"] as? String {
                resultDecodedBuilder.nameApp = jsonValueNameApp
            }
            if let jsonValueDeviceIp = jsonMap["deviceIP"] as? String {
                resultDecodedBuilder.deviceIp = jsonValueDeviceIp
            }
            if let jsonValuePageViews = jsonMap["pageViews"] as? Array<Dictionary<String,Any>> {
                var jsonArrayPageViews:Array<PageView> = []
                for oneValuePageViews in jsonValuePageViews {
                    let messageFromStringPageViews = try PageView.Builder.decodeToBuilder(jsonMap:oneValuePageViews).build()

                    jsonArrayPageViews.append(messageFromStringPageViews)
                }
                resultDecodedBuilder.pageViews = jsonArrayPageViews
            }
            if let jsonValueTypeConnection = jsonMap["typeConnection"] as? String {
                resultDecodedBuilder.typeConnection = jsonValueTypeConnection
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Track.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Track.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class PageView : GeneratedMessage {
    public typealias BuilderType = PageView.Builder

    public static func == (lhs: PageView, rhs: PageView) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasActivity == rhs.hasActivity) && (!lhs.hasActivity || lhs.activity == rhs.activity)
        fieldCheck = fieldCheck && (lhs.hasDateTime == rhs.hasDateTime) && (!lhs.hasDateTime || lhs.dateTime == rhs.dateTime)
        fieldCheck = fieldCheck && (lhs.hasTitlePage == rhs.hasTitlePage) && (!lhs.hasTitlePage || lhs.titlePage == rhs.titlePage)
        fieldCheck = fieldCheck && (lhs.hasCallPage == rhs.hasCallPage) && (!lhs.hasCallPage || lhs.callPage == rhs.callPage)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var activity:String! = nil
    public fileprivate(set) var hasActivity:Bool = false

    public fileprivate(set) var dateTime:UInt64! = nil
    public fileprivate(set) var hasDateTime:Bool = false

    public fileprivate(set) var titlePage:String! = nil
    public fileprivate(set) var hasTitlePage:Bool = false

    public fileprivate(set) var callPage:String! = nil
    public fileprivate(set) var hasCallPage:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasActivity {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PageView.self): field \"activity\" mark required")
        }
        if !hasDateTime {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PageView.self): field \"dateTime\" mark required")
        }
        if !hasTitlePage {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(PageView.self): field \"titlePage\" mark required")
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasActivity {
            try codedOutputStream.writeString(fieldNumber: 1, value:activity)
        }
        if hasDateTime {
            try codedOutputStream.writeUInt64(fieldNumber: 2, value:dateTime)
        }
        if hasTitlePage {
            try codedOutputStream.writeString(fieldNumber: 3, value:titlePage)
        }
        if hasCallPage {
            try codedOutputStream.writeString(fieldNumber: 4, value:callPage)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasActivity {
            serialize_size += activity.computeStringSize(fieldNumber: 1)
        }
        if hasDateTime {
            serialize_size += dateTime.computeUInt64Size(fieldNumber: 2)
        }
        if hasTitlePage {
            serialize_size += titlePage.computeStringSize(fieldNumber: 3)
        }
        if hasCallPage {
            serialize_size += callPage.computeStringSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PageView.Builder {
        return PageView.classBuilder() as! PageView.Builder
    }
    public func getBuilder() -> PageView.Builder {
        return classBuilder() as! PageView.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PageView.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PageView.Builder()
    }
    public func toBuilder() throws -> PageView.Builder {
        return try PageView.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PageView) throws -> PageView.Builder {
        return try PageView.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasActivity {
            jsonMap["activity"] = activity
        }
        if hasDateTime {
            jsonMap["dateTime"] = "\(dateTime!)"
        }
        if hasTitlePage {
            jsonMap["titlePage"] = titlePage
        }
        if hasCallPage {
            jsonMap["callPage"] = callPage
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PageView {
        return try PageView.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> PageView {
        return try PageView.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasActivity {
            output += "\(indent) activity: \(activity) \n"
        }
        if hasDateTime {
            output += "\(indent) dateTime: \(dateTime) \n"
        }
        if hasTitlePage {
            output += "\(indent) titlePage: \(titlePage) \n"
        }
        if hasCallPage {
            output += "\(indent) callPage: \(callPage) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasActivity {
                hashCode = (hashCode &* 31) &+ activity.hashValue
            }
            if hasDateTime {
                hashCode = (hashCode &* 31) &+ dateTime.hashValue
            }
            if hasTitlePage {
                hashCode = (hashCode &* 31) &+ titlePage.hashValue
            }
            if hasCallPage {
                hashCode = (hashCode &* 31) &+ callPage.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PageView"
    }
    override public func className() -> String {
        return "PageView"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PageView = PageView()
        public func getMessage() -> PageView {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var activity:String {
            get {
                return builderResult.activity
            }
            set (value) {
                builderResult.hasActivity = true
                builderResult.activity = value
            }
        }
        public var hasActivity:Bool {
            get {
                return builderResult.hasActivity
            }
        }
        @discardableResult
        public func setActivity(_ value:String) -> PageView.Builder {
            self.activity = value
            return self
        }
        @discardableResult
        public func clearActivity() -> PageView.Builder{
            builderResult.hasActivity = false
            builderResult.activity = nil
            return self
        }
        public var dateTime:UInt64 {
            get {
                return builderResult.dateTime
            }
            set (value) {
                builderResult.hasDateTime = true
                builderResult.dateTime = value
            }
        }
        public var hasDateTime:Bool {
            get {
                return builderResult.hasDateTime
            }
        }
        @discardableResult
        public func setDateTime(_ value:UInt64) -> PageView.Builder {
            self.dateTime = value
            return self
        }
        @discardableResult
        public func clearDateTime() -> PageView.Builder{
            builderResult.hasDateTime = false
            builderResult.dateTime = nil
            return self
        }
        public var titlePage:String {
            get {
                return builderResult.titlePage
            }
            set (value) {
                builderResult.hasTitlePage = true
                builderResult.titlePage = value
            }
        }
        public var hasTitlePage:Bool {
            get {
                return builderResult.hasTitlePage
            }
        }
        @discardableResult
        public func setTitlePage(_ value:String) -> PageView.Builder {
            self.titlePage = value
            return self
        }
        @discardableResult
        public func clearTitlePage() -> PageView.Builder{
            builderResult.hasTitlePage = false
            builderResult.titlePage = nil
            return self
        }
        public var callPage:String {
            get {
                return builderResult.callPage
            }
            set (value) {
                builderResult.hasCallPage = true
                builderResult.callPage = value
            }
        }
        public var hasCallPage:Bool {
            get {
                return builderResult.hasCallPage
            }
        }
        @discardableResult
        public func setCallPage(_ value:String) -> PageView.Builder {
            self.callPage = value
            return self
        }
        @discardableResult
        public func clearCallPage() -> PageView.Builder{
            builderResult.hasCallPage = false
            builderResult.callPage = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PageView.Builder {
            builderResult = PageView()
            return self
        }
        override public func clone() throws -> PageView.Builder {
            return try PageView.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PageView {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PageView {
            let returnMe:PageView = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PageView) throws -> PageView.Builder {
            if other == PageView() {
                return self
            }
            if other.hasActivity {
                activity = other.activity
            }
            if other.hasDateTime {
                dateTime = other.dateTime
            }
            if other.hasTitlePage {
                titlePage = other.titlePage
            }
            if other.hasCallPage {
                callPage = other.callPage
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PageView.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PageView.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    activity = try codedInputStream.readString()

                case 16:
                    dateTime = try codedInputStream.readUInt64()

                case 26:
                    titlePage = try codedInputStream.readString()

                case 34:
                    callPage = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PageView.Builder {
            let resultDecodedBuilder = PageView.Builder()
            if let jsonValueActivity = jsonMap["activity"] as? String {
                resultDecodedBuilder.activity = jsonValueActivity
            }
            if let jsonValueDateTime = jsonMap["dateTime"] as? String {
                resultDecodedBuilder.dateTime = UInt64(jsonValueDateTime)!
            } else if let jsonValueDateTime = jsonMap["dateTime"] as? UInt {
                resultDecodedBuilder.dateTime = UInt64(jsonValueDateTime)
            }
            if let jsonValueTitlePage = jsonMap["titlePage"] as? String {
                resultDecodedBuilder.titlePage = jsonValueTitlePage
            }
            if let jsonValueCallPage = jsonMap["callPage"] as? String {
                resultDecodedBuilder.callPage = jsonValueCallPage
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> PageView.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PageView.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class MobileInfo : GeneratedMessage {
    public typealias BuilderType = MobileInfo.Builder

    public static func == (lhs: MobileInfo, rhs: MobileInfo) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasDeviceId == rhs.hasDeviceId) && (!lhs.hasDeviceId || lhs.deviceId == rhs.deviceId)
        fieldCheck = fieldCheck && (lhs.hasPlatform == rhs.hasPlatform) && (!lhs.hasPlatform || lhs.platform == rhs.platform)
        fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
        fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
        fieldCheck = fieldCheck && (lhs.hasAndroidName == rhs.hasAndroidName) && (!lhs.hasAndroidName || lhs.androidName == rhs.androidName)
        fieldCheck = fieldCheck && (lhs.hasAndroidBrand == rhs.hasAndroidBrand) && (!lhs.hasAndroidBrand || lhs.androidBrand == rhs.androidBrand)
        fieldCheck = fieldCheck && (lhs.hasAndroidModel == rhs.hasAndroidModel) && (!lhs.hasAndroidModel || lhs.androidModel == rhs.androidModel)
        fieldCheck = fieldCheck && (lhs.hasVersionRelease == rhs.hasVersionRelease) && (!lhs.hasVersionRelease || lhs.versionRelease == rhs.versionRelease)
        fieldCheck = fieldCheck && (lhs.hasManufacturer == rhs.hasManufacturer) && (!lhs.hasManufacturer || lhs.manufacturer == rhs.manufacturer)
        fieldCheck = fieldCheck && (lhs.hasVersionLib == rhs.hasVersionLib) && (!lhs.hasVersionLib || lhs.versionLib == rhs.versionLib)
        fieldCheck = fieldCheck && (lhs.hasVersionCode == rhs.hasVersionCode) && (!lhs.hasVersionCode || lhs.versionCode == rhs.versionCode)
        fieldCheck = fieldCheck && (lhs.hasVersionOs == rhs.hasVersionOs) && (!lhs.hasVersionOs || lhs.versionOs == rhs.versionOs)
        fieldCheck = fieldCheck && (lhs.hasAndroidFingerPrint == rhs.hasAndroidFingerPrint) && (!lhs.hasAndroidFingerPrint || lhs.androidFingerPrint == rhs.androidFingerPrint)
        fieldCheck = fieldCheck && (lhs.hasUserAgent == rhs.hasUserAgent) && (!lhs.hasUserAgent || lhs.userAgent == rhs.userAgent)
        fieldCheck = fieldCheck && (lhs.hasLinkPlayStore == rhs.hasLinkPlayStore) && (!lhs.hasLinkPlayStore || lhs.linkPlayStore == rhs.linkPlayStore)
        fieldCheck = fieldCheck && (lhs.hasTypeCategory == rhs.hasTypeCategory) && (!lhs.hasTypeCategory || lhs.typeCategory == rhs.typeCategory)
        fieldCheck = fieldCheck && (lhs.hasImei == rhs.hasImei) && (!lhs.hasImei || lhs.imei == rhs.imei)
        fieldCheck = fieldCheck && (lhs.hasSoftwareVersion == rhs.hasSoftwareVersion) && (!lhs.hasSoftwareVersion || lhs.softwareVersion == rhs.softwareVersion)
        fieldCheck = fieldCheck && (lhs.hasLanguageApp == rhs.hasLanguageApp) && (!lhs.hasLanguageApp || lhs.languageApp == rhs.languageApp)
        fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
        fieldCheck = fieldCheck && (lhs.hasAcc == rhs.hasAcc) && (!lhs.hasAcc || lhs.acc == rhs.acc)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var deviceId:String! = nil
    public fileprivate(set) var hasDeviceId:Bool = false

    public fileprivate(set) var platform:String! = nil
    public fileprivate(set) var hasPlatform:Bool = false

    public fileprivate(set) var longitude:String! = nil
    public fileprivate(set) var hasLongitude:Bool = false

    public fileprivate(set) var latitude:String! = nil
    public fileprivate(set) var hasLatitude:Bool = false

    public fileprivate(set) var androidName:String! = nil
    public fileprivate(set) var hasAndroidName:Bool = false

    public fileprivate(set) var androidBrand:String! = nil
    public fileprivate(set) var hasAndroidBrand:Bool = false

    public fileprivate(set) var androidModel:String! = nil
    public fileprivate(set) var hasAndroidModel:Bool = false

    public fileprivate(set) var versionRelease:String! = nil
    public fileprivate(set) var hasVersionRelease:Bool = false

    public fileprivate(set) var manufacturer:String! = nil
    public fileprivate(set) var hasManufacturer:Bool = false

    public fileprivate(set) var versionLib:String! = nil
    public fileprivate(set) var hasVersionLib:Bool = false

    public fileprivate(set) var versionCode:Int32! = nil
    public fileprivate(set) var hasVersionCode:Bool = false

    public fileprivate(set) var versionOs:Int32! = nil
    public fileprivate(set) var hasVersionOs:Bool = false

    public fileprivate(set) var androidFingerPrint:String! = nil
    public fileprivate(set) var hasAndroidFingerPrint:Bool = false

    public fileprivate(set) var userAgent:String! = nil
    public fileprivate(set) var hasUserAgent:Bool = false

    public fileprivate(set) var linkPlayStore:String! = nil
    public fileprivate(set) var hasLinkPlayStore:Bool = false

    public fileprivate(set) var typeCategory:String! = nil
    public fileprivate(set) var hasTypeCategory:Bool = false

    public fileprivate(set) var imei:String! = nil
    public fileprivate(set) var hasImei:Bool = false

    public fileprivate(set) var softwareVersion:String! = nil
    public fileprivate(set) var hasSoftwareVersion:Bool = false

    public fileprivate(set) var languageApp:String! = nil
    public fileprivate(set) var hasLanguageApp:Bool = false

    public fileprivate(set) var userId:String! = nil
    public fileprivate(set) var hasUserId:Bool = false

    public fileprivate(set) var acc:UInt32! = nil
    public fileprivate(set) var hasAcc:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
        if !hasUserId {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(MobileInfo.self): field \"userId\" mark required")
        }
        if !hasAcc {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message \(MobileInfo.self): field \"acc\" mark required")
        }
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasDeviceId {
            try codedOutputStream.writeString(fieldNumber: 1, value:deviceId)
        }
        if hasPlatform {
            try codedOutputStream.writeString(fieldNumber: 2, value:platform)
        }
        if hasLongitude {
            try codedOutputStream.writeString(fieldNumber: 3, value:longitude)
        }
        if hasLatitude {
            try codedOutputStream.writeString(fieldNumber: 4, value:latitude)
        }
        if hasAndroidName {
            try codedOutputStream.writeString(fieldNumber: 5, value:androidName)
        }
        if hasAndroidBrand {
            try codedOutputStream.writeString(fieldNumber: 6, value:androidBrand)
        }
        if hasAndroidModel {
            try codedOutputStream.writeString(fieldNumber: 7, value:androidModel)
        }
        if hasVersionRelease {
            try codedOutputStream.writeString(fieldNumber: 8, value:versionRelease)
        }
        if hasManufacturer {
            try codedOutputStream.writeString(fieldNumber: 9, value:manufacturer)
        }
        if hasVersionLib {
            try codedOutputStream.writeString(fieldNumber: 10, value:versionLib)
        }
        if hasVersionCode {
            try codedOutputStream.writeInt32(fieldNumber: 11, value:versionCode)
        }
        if hasVersionOs {
            try codedOutputStream.writeInt32(fieldNumber: 12, value:versionOs)
        }
        if hasAndroidFingerPrint {
            try codedOutputStream.writeString(fieldNumber: 13, value:androidFingerPrint)
        }
        if hasUserAgent {
            try codedOutputStream.writeString(fieldNumber: 14, value:userAgent)
        }
        if hasLinkPlayStore {
            try codedOutputStream.writeString(fieldNumber: 15, value:linkPlayStore)
        }
        if hasTypeCategory {
            try codedOutputStream.writeString(fieldNumber: 16, value:typeCategory)
        }
        if hasImei {
            try codedOutputStream.writeString(fieldNumber: 17, value:imei)
        }
        if hasSoftwareVersion {
            try codedOutputStream.writeString(fieldNumber: 18, value:softwareVersion)
        }
        if hasLanguageApp {
            try codedOutputStream.writeString(fieldNumber: 19, value:languageApp)
        }
        if hasUserId {
            try codedOutputStream.writeString(fieldNumber: 20, value:userId)
        }
        if hasAcc {
            try codedOutputStream.writeUInt32(fieldNumber: 21, value:acc)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasDeviceId {
            serialize_size += deviceId.computeStringSize(fieldNumber: 1)
        }
        if hasPlatform {
            serialize_size += platform.computeStringSize(fieldNumber: 2)
        }
        if hasLongitude {
            serialize_size += longitude.computeStringSize(fieldNumber: 3)
        }
        if hasLatitude {
            serialize_size += latitude.computeStringSize(fieldNumber: 4)
        }
        if hasAndroidName {
            serialize_size += androidName.computeStringSize(fieldNumber: 5)
        }
        if hasAndroidBrand {
            serialize_size += androidBrand.computeStringSize(fieldNumber: 6)
        }
        if hasAndroidModel {
            serialize_size += androidModel.computeStringSize(fieldNumber: 7)
        }
        if hasVersionRelease {
            serialize_size += versionRelease.computeStringSize(fieldNumber: 8)
        }
        if hasManufacturer {
            serialize_size += manufacturer.computeStringSize(fieldNumber: 9)
        }
        if hasVersionLib {
            serialize_size += versionLib.computeStringSize(fieldNumber: 10)
        }
        if hasVersionCode {
            serialize_size += versionCode.computeInt32Size(fieldNumber: 11)
        }
        if hasVersionOs {
            serialize_size += versionOs.computeInt32Size(fieldNumber: 12)
        }
        if hasAndroidFingerPrint {
            serialize_size += androidFingerPrint.computeStringSize(fieldNumber: 13)
        }
        if hasUserAgent {
            serialize_size += userAgent.computeStringSize(fieldNumber: 14)
        }
        if hasLinkPlayStore {
            serialize_size += linkPlayStore.computeStringSize(fieldNumber: 15)
        }
        if hasTypeCategory {
            serialize_size += typeCategory.computeStringSize(fieldNumber: 16)
        }
        if hasImei {
            serialize_size += imei.computeStringSize(fieldNumber: 17)
        }
        if hasSoftwareVersion {
            serialize_size += softwareVersion.computeStringSize(fieldNumber: 18)
        }
        if hasLanguageApp {
            serialize_size += languageApp.computeStringSize(fieldNumber: 19)
        }
        if hasUserId {
            serialize_size += userId.computeStringSize(fieldNumber: 20)
        }
        if hasAcc {
            serialize_size += acc.computeUInt32Size(fieldNumber: 21)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> MobileInfo.Builder {
        return MobileInfo.classBuilder() as! MobileInfo.Builder
    }
    public func getBuilder() -> MobileInfo.Builder {
        return classBuilder() as! MobileInfo.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return MobileInfo.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return MobileInfo.Builder()
    }
    public func toBuilder() throws -> MobileInfo.Builder {
        return try MobileInfo.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:MobileInfo) throws -> MobileInfo.Builder {
        return try MobileInfo.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasDeviceId {
            jsonMap["deviceId"] = deviceId
        }
        if hasPlatform {
            jsonMap["platform"] = platform
        }
        if hasLongitude {
            jsonMap["longitude"] = longitude
        }
        if hasLatitude {
            jsonMap["latitude"] = latitude
        }
        if hasAndroidName {
            jsonMap["androidName"] = androidName
        }
        if hasAndroidBrand {
            jsonMap["androidBrand"] = androidBrand
        }
        if hasAndroidModel {
            jsonMap["androidModel"] = androidModel
        }
        if hasVersionRelease {
            jsonMap["versionRelease"] = versionRelease
        }
        if hasManufacturer {
            jsonMap["manufacturer"] = manufacturer
        }
        if hasVersionLib {
            jsonMap["versionLib"] = versionLib
        }
        if hasVersionCode {
            jsonMap["versionCode"] = Int(versionCode)
        }
        if hasVersionOs {
            jsonMap["versionOS"] = Int(versionOs)
        }
        if hasAndroidFingerPrint {
            jsonMap["androidFingerPrint"] = androidFingerPrint
        }
        if hasUserAgent {
            jsonMap["userAgent"] = userAgent
        }
        if hasLinkPlayStore {
            jsonMap["linkPlayStore"] = linkPlayStore
        }
        if hasTypeCategory {
            jsonMap["typeCategory"] = typeCategory
        }
        if hasImei {
            jsonMap["imei"] = imei
        }
        if hasSoftwareVersion {
            jsonMap["softwareVersion"] = softwareVersion
        }
        if hasLanguageApp {
            jsonMap["languageApp"] = languageApp
        }
        if hasUserId {
            jsonMap["userId"] = userId
        }
        if hasAcc {
            jsonMap["acc"] = UInt(acc)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> MobileInfo {
        return try MobileInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> MobileInfo {
        return try MobileInfo.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasDeviceId {
            output += "\(indent) deviceId: \(deviceId) \n"
        }
        if hasPlatform {
            output += "\(indent) platform: \(platform) \n"
        }
        if hasLongitude {
            output += "\(indent) longitude: \(longitude) \n"
        }
        if hasLatitude {
            output += "\(indent) latitude: \(latitude) \n"
        }
        if hasAndroidName {
            output += "\(indent) androidName: \(androidName) \n"
        }
        if hasAndroidBrand {
            output += "\(indent) androidBrand: \(androidBrand) \n"
        }
        if hasAndroidModel {
            output += "\(indent) androidModel: \(androidModel) \n"
        }
        if hasVersionRelease {
            output += "\(indent) versionRelease: \(versionRelease) \n"
        }
        if hasManufacturer {
            output += "\(indent) manufacturer: \(manufacturer) \n"
        }
        if hasVersionLib {
            output += "\(indent) versionLib: \(versionLib) \n"
        }
        if hasVersionCode {
            output += "\(indent) versionCode: \(versionCode) \n"
        }
        if hasVersionOs {
            output += "\(indent) versionOs: \(versionOs) \n"
        }
        if hasAndroidFingerPrint {
            output += "\(indent) androidFingerPrint: \(androidFingerPrint) \n"
        }
        if hasUserAgent {
            output += "\(indent) userAgent: \(userAgent) \n"
        }
        if hasLinkPlayStore {
            output += "\(indent) linkPlayStore: \(linkPlayStore) \n"
        }
        if hasTypeCategory {
            output += "\(indent) typeCategory: \(typeCategory) \n"
        }
        if hasImei {
            output += "\(indent) imei: \(imei) \n"
        }
        if hasSoftwareVersion {
            output += "\(indent) softwareVersion: \(softwareVersion) \n"
        }
        if hasLanguageApp {
            output += "\(indent) languageApp: \(languageApp) \n"
        }
        if hasUserId {
            output += "\(indent) userId: \(userId) \n"
        }
        if hasAcc {
            output += "\(indent) acc: \(acc) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeviceId {
                hashCode = (hashCode &* 31) &+ deviceId.hashValue
            }
            if hasPlatform {
                hashCode = (hashCode &* 31) &+ platform.hashValue
            }
            if hasLongitude {
                hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            if hasLatitude {
                hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasAndroidName {
                hashCode = (hashCode &* 31) &+ androidName.hashValue
            }
            if hasAndroidBrand {
                hashCode = (hashCode &* 31) &+ androidBrand.hashValue
            }
            if hasAndroidModel {
                hashCode = (hashCode &* 31) &+ androidModel.hashValue
            }
            if hasVersionRelease {
                hashCode = (hashCode &* 31) &+ versionRelease.hashValue
            }
            if hasManufacturer {
                hashCode = (hashCode &* 31) &+ manufacturer.hashValue
            }
            if hasVersionLib {
                hashCode = (hashCode &* 31) &+ versionLib.hashValue
            }
            if hasVersionCode {
                hashCode = (hashCode &* 31) &+ versionCode.hashValue
            }
            if hasVersionOs {
                hashCode = (hashCode &* 31) &+ versionOs.hashValue
            }
            if hasAndroidFingerPrint {
                hashCode = (hashCode &* 31) &+ androidFingerPrint.hashValue
            }
            if hasUserAgent {
                hashCode = (hashCode &* 31) &+ userAgent.hashValue
            }
            if hasLinkPlayStore {
                hashCode = (hashCode &* 31) &+ linkPlayStore.hashValue
            }
            if hasTypeCategory {
                hashCode = (hashCode &* 31) &+ typeCategory.hashValue
            }
            if hasImei {
                hashCode = (hashCode &* 31) &+ imei.hashValue
            }
            if hasSoftwareVersion {
                hashCode = (hashCode &* 31) &+ softwareVersion.hashValue
            }
            if hasLanguageApp {
                hashCode = (hashCode &* 31) &+ languageApp.hashValue
            }
            if hasUserId {
                hashCode = (hashCode &* 31) &+ userId.hashValue
            }
            if hasAcc {
                hashCode = (hashCode &* 31) &+ acc.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "MobileInfo"
    }
    override public func className() -> String {
        return "MobileInfo"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:MobileInfo = MobileInfo()
        public func getMessage() -> MobileInfo {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var deviceId:String {
            get {
                return builderResult.deviceId
            }
            set (value) {
                builderResult.hasDeviceId = true
                builderResult.deviceId = value
            }
        }
        public var hasDeviceId:Bool {
            get {
                return builderResult.hasDeviceId
            }
        }
        @discardableResult
        public func setDeviceId(_ value:String) -> MobileInfo.Builder {
            self.deviceId = value
            return self
        }
        @discardableResult
        public func clearDeviceId() -> MobileInfo.Builder{
            builderResult.hasDeviceId = false
            builderResult.deviceId = nil
            return self
        }
        public var platform:String {
            get {
                return builderResult.platform
            }
            set (value) {
                builderResult.hasPlatform = true
                builderResult.platform = value
            }
        }
        public var hasPlatform:Bool {
            get {
                return builderResult.hasPlatform
            }
        }
        @discardableResult
        public func setPlatform(_ value:String) -> MobileInfo.Builder {
            self.platform = value
            return self
        }
        @discardableResult
        public func clearPlatform() -> MobileInfo.Builder{
            builderResult.hasPlatform = false
            builderResult.platform = nil
            return self
        }
        public var longitude:String {
            get {
                return builderResult.longitude
            }
            set (value) {
                builderResult.hasLongitude = true
                builderResult.longitude = value
            }
        }
        public var hasLongitude:Bool {
            get {
                return builderResult.hasLongitude
            }
        }
        @discardableResult
        public func setLongitude(_ value:String) -> MobileInfo.Builder {
            self.longitude = value
            return self
        }
        @discardableResult
        public func clearLongitude() -> MobileInfo.Builder{
            builderResult.hasLongitude = false
            builderResult.longitude = nil
            return self
        }
        public var latitude:String {
            get {
                return builderResult.latitude
            }
            set (value) {
                builderResult.hasLatitude = true
                builderResult.latitude = value
            }
        }
        public var hasLatitude:Bool {
            get {
                return builderResult.hasLatitude
            }
        }
        @discardableResult
        public func setLatitude(_ value:String) -> MobileInfo.Builder {
            self.latitude = value
            return self
        }
        @discardableResult
        public func clearLatitude() -> MobileInfo.Builder{
            builderResult.hasLatitude = false
            builderResult.latitude = nil
            return self
        }
        public var androidName:String {
            get {
                return builderResult.androidName
            }
            set (value) {
                builderResult.hasAndroidName = true
                builderResult.androidName = value
            }
        }
        public var hasAndroidName:Bool {
            get {
                return builderResult.hasAndroidName
            }
        }
        @discardableResult
        public func setAndroidName(_ value:String) -> MobileInfo.Builder {
            self.androidName = value
            return self
        }
        @discardableResult
        public func clearAndroidName() -> MobileInfo.Builder{
            builderResult.hasAndroidName = false
            builderResult.androidName = nil
            return self
        }
        public var androidBrand:String {
            get {
                return builderResult.androidBrand
            }
            set (value) {
                builderResult.hasAndroidBrand = true
                builderResult.androidBrand = value
            }
        }
        public var hasAndroidBrand:Bool {
            get {
                return builderResult.hasAndroidBrand
            }
        }
        @discardableResult
        public func setAndroidBrand(_ value:String) -> MobileInfo.Builder {
            self.androidBrand = value
            return self
        }
        @discardableResult
        public func clearAndroidBrand() -> MobileInfo.Builder{
            builderResult.hasAndroidBrand = false
            builderResult.androidBrand = nil
            return self
        }
        public var androidModel:String {
            get {
                return builderResult.androidModel
            }
            set (value) {
                builderResult.hasAndroidModel = true
                builderResult.androidModel = value
            }
        }
        public var hasAndroidModel:Bool {
            get {
                return builderResult.hasAndroidModel
            }
        }
        @discardableResult
        public func setAndroidModel(_ value:String) -> MobileInfo.Builder {
            self.androidModel = value
            return self
        }
        @discardableResult
        public func clearAndroidModel() -> MobileInfo.Builder{
            builderResult.hasAndroidModel = false
            builderResult.androidModel = nil
            return self
        }
        public var versionRelease:String {
            get {
                return builderResult.versionRelease
            }
            set (value) {
                builderResult.hasVersionRelease = true
                builderResult.versionRelease = value
            }
        }
        public var hasVersionRelease:Bool {
            get {
                return builderResult.hasVersionRelease
            }
        }
        @discardableResult
        public func setVersionRelease(_ value:String) -> MobileInfo.Builder {
            self.versionRelease = value
            return self
        }
        @discardableResult
        public func clearVersionRelease() -> MobileInfo.Builder{
            builderResult.hasVersionRelease = false
            builderResult.versionRelease = nil
            return self
        }
        public var manufacturer:String {
            get {
                return builderResult.manufacturer
            }
            set (value) {
                builderResult.hasManufacturer = true
                builderResult.manufacturer = value
            }
        }
        public var hasManufacturer:Bool {
            get {
                return builderResult.hasManufacturer
            }
        }
        @discardableResult
        public func setManufacturer(_ value:String) -> MobileInfo.Builder {
            self.manufacturer = value
            return self
        }
        @discardableResult
        public func clearManufacturer() -> MobileInfo.Builder{
            builderResult.hasManufacturer = false
            builderResult.manufacturer = nil
            return self
        }
        public var versionLib:String {
            get {
                return builderResult.versionLib
            }
            set (value) {
                builderResult.hasVersionLib = true
                builderResult.versionLib = value
            }
        }
        public var hasVersionLib:Bool {
            get {
                return builderResult.hasVersionLib
            }
        }
        @discardableResult
        public func setVersionLib(_ value:String) -> MobileInfo.Builder {
            self.versionLib = value
            return self
        }
        @discardableResult
        public func clearVersionLib() -> MobileInfo.Builder{
            builderResult.hasVersionLib = false
            builderResult.versionLib = nil
            return self
        }
        public var versionCode:Int32 {
            get {
                return builderResult.versionCode
            }
            set (value) {
                builderResult.hasVersionCode = true
                builderResult.versionCode = value
            }
        }
        public var hasVersionCode:Bool {
            get {
                return builderResult.hasVersionCode
            }
        }
        @discardableResult
        public func setVersionCode(_ value:Int32) -> MobileInfo.Builder {
            self.versionCode = value
            return self
        }
        @discardableResult
        public func clearVersionCode() -> MobileInfo.Builder{
            builderResult.hasVersionCode = false
            builderResult.versionCode = nil
            return self
        }
        public var versionOs:Int32 {
            get {
                return builderResult.versionOs
            }
            set (value) {
                builderResult.hasVersionOs = true
                builderResult.versionOs = value
            }
        }
        public var hasVersionOs:Bool {
            get {
                return builderResult.hasVersionOs
            }
        }
        @discardableResult
        public func setVersionOs(_ value:Int32) -> MobileInfo.Builder {
            self.versionOs = value
            return self
        }
        @discardableResult
        public func clearVersionOs() -> MobileInfo.Builder{
            builderResult.hasVersionOs = false
            builderResult.versionOs = nil
            return self
        }
        public var androidFingerPrint:String {
            get {
                return builderResult.androidFingerPrint
            }
            set (value) {
                builderResult.hasAndroidFingerPrint = true
                builderResult.androidFingerPrint = value
            }
        }
        public var hasAndroidFingerPrint:Bool {
            get {
                return builderResult.hasAndroidFingerPrint
            }
        }
        @discardableResult
        public func setAndroidFingerPrint(_ value:String) -> MobileInfo.Builder {
            self.androidFingerPrint = value
            return self
        }
        @discardableResult
        public func clearAndroidFingerPrint() -> MobileInfo.Builder{
            builderResult.hasAndroidFingerPrint = false
            builderResult.androidFingerPrint = nil
            return self
        }
        public var userAgent:String {
            get {
                return builderResult.userAgent
            }
            set (value) {
                builderResult.hasUserAgent = true
                builderResult.userAgent = value
            }
        }
        public var hasUserAgent:Bool {
            get {
                return builderResult.hasUserAgent
            }
        }
        @discardableResult
        public func setUserAgent(_ value:String) -> MobileInfo.Builder {
            self.userAgent = value
            return self
        }
        @discardableResult
        public func clearUserAgent() -> MobileInfo.Builder{
            builderResult.hasUserAgent = false
            builderResult.userAgent = nil
            return self
        }
        public var linkPlayStore:String {
            get {
                return builderResult.linkPlayStore
            }
            set (value) {
                builderResult.hasLinkPlayStore = true
                builderResult.linkPlayStore = value
            }
        }
        public var hasLinkPlayStore:Bool {
            get {
                return builderResult.hasLinkPlayStore
            }
        }
        @discardableResult
        public func setLinkPlayStore(_ value:String) -> MobileInfo.Builder {
            self.linkPlayStore = value
            return self
        }
        @discardableResult
        public func clearLinkPlayStore() -> MobileInfo.Builder{
            builderResult.hasLinkPlayStore = false
            builderResult.linkPlayStore = nil
            return self
        }
        public var typeCategory:String {
            get {
                return builderResult.typeCategory
            }
            set (value) {
                builderResult.hasTypeCategory = true
                builderResult.typeCategory = value
            }
        }
        public var hasTypeCategory:Bool {
            get {
                return builderResult.hasTypeCategory
            }
        }
        @discardableResult
        public func setTypeCategory(_ value:String) -> MobileInfo.Builder {
            self.typeCategory = value
            return self
        }
        @discardableResult
        public func clearTypeCategory() -> MobileInfo.Builder{
            builderResult.hasTypeCategory = false
            builderResult.typeCategory = nil
            return self
        }
        public var imei:String {
            get {
                return builderResult.imei
            }
            set (value) {
                builderResult.hasImei = true
                builderResult.imei = value
            }
        }
        public var hasImei:Bool {
            get {
                return builderResult.hasImei
            }
        }
        @discardableResult
        public func setImei(_ value:String) -> MobileInfo.Builder {
            self.imei = value
            return self
        }
        @discardableResult
        public func clearImei() -> MobileInfo.Builder{
            builderResult.hasImei = false
            builderResult.imei = nil
            return self
        }
        public var softwareVersion:String {
            get {
                return builderResult.softwareVersion
            }
            set (value) {
                builderResult.hasSoftwareVersion = true
                builderResult.softwareVersion = value
            }
        }
        public var hasSoftwareVersion:Bool {
            get {
                return builderResult.hasSoftwareVersion
            }
        }
        @discardableResult
        public func setSoftwareVersion(_ value:String) -> MobileInfo.Builder {
            self.softwareVersion = value
            return self
        }
        @discardableResult
        public func clearSoftwareVersion() -> MobileInfo.Builder{
            builderResult.hasSoftwareVersion = false
            builderResult.softwareVersion = nil
            return self
        }
        public var languageApp:String {
            get {
                return builderResult.languageApp
            }
            set (value) {
                builderResult.hasLanguageApp = true
                builderResult.languageApp = value
            }
        }
        public var hasLanguageApp:Bool {
            get {
                return builderResult.hasLanguageApp
            }
        }
        @discardableResult
        public func setLanguageApp(_ value:String) -> MobileInfo.Builder {
            self.languageApp = value
            return self
        }
        @discardableResult
        public func clearLanguageApp() -> MobileInfo.Builder{
            builderResult.hasLanguageApp = false
            builderResult.languageApp = nil
            return self
        }
        public var userId:String {
            get {
                return builderResult.userId
            }
            set (value) {
                builderResult.hasUserId = true
                builderResult.userId = value
            }
        }
        public var hasUserId:Bool {
            get {
                return builderResult.hasUserId
            }
        }
        @discardableResult
        public func setUserId(_ value:String) -> MobileInfo.Builder {
            self.userId = value
            return self
        }
        @discardableResult
        public func clearUserId() -> MobileInfo.Builder{
            builderResult.hasUserId = false
            builderResult.userId = nil
            return self
        }
        public var acc:UInt32 {
            get {
                return builderResult.acc
            }
            set (value) {
                builderResult.hasAcc = true
                builderResult.acc = value
            }
        }
        public var hasAcc:Bool {
            get {
                return builderResult.hasAcc
            }
        }
        @discardableResult
        public func setAcc(_ value:UInt32) -> MobileInfo.Builder {
            self.acc = value
            return self
        }
        @discardableResult
        public func clearAcc() -> MobileInfo.Builder{
            builderResult.hasAcc = false
            builderResult.acc = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> MobileInfo.Builder {
            builderResult = MobileInfo()
            return self
        }
        override public func clone() throws -> MobileInfo.Builder {
            return try MobileInfo.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> MobileInfo {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> MobileInfo {
            let returnMe:MobileInfo = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:MobileInfo) throws -> MobileInfo.Builder {
            if other == MobileInfo() {
                return self
            }
            if other.hasDeviceId {
                deviceId = other.deviceId
            }
            if other.hasPlatform {
                platform = other.platform
            }
            if other.hasLongitude {
                longitude = other.longitude
            }
            if other.hasLatitude {
                latitude = other.latitude
            }
            if other.hasAndroidName {
                androidName = other.androidName
            }
            if other.hasAndroidBrand {
                androidBrand = other.androidBrand
            }
            if other.hasAndroidModel {
                androidModel = other.androidModel
            }
            if other.hasVersionRelease {
                versionRelease = other.versionRelease
            }
            if other.hasManufacturer {
                manufacturer = other.manufacturer
            }
            if other.hasVersionLib {
                versionLib = other.versionLib
            }
            if other.hasVersionCode {
                versionCode = other.versionCode
            }
            if other.hasVersionOs {
                versionOs = other.versionOs
            }
            if other.hasAndroidFingerPrint {
                androidFingerPrint = other.androidFingerPrint
            }
            if other.hasUserAgent {
                userAgent = other.userAgent
            }
            if other.hasLinkPlayStore {
                linkPlayStore = other.linkPlayStore
            }
            if other.hasTypeCategory {
                typeCategory = other.typeCategory
            }
            if other.hasImei {
                imei = other.imei
            }
            if other.hasSoftwareVersion {
                softwareVersion = other.softwareVersion
            }
            if other.hasLanguageApp {
                languageApp = other.languageApp
            }
            if other.hasUserId {
                userId = other.userId
            }
            if other.hasAcc {
                acc = other.acc
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> MobileInfo.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MobileInfo.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    deviceId = try codedInputStream.readString()

                case 18:
                    platform = try codedInputStream.readString()

                case 26:
                    longitude = try codedInputStream.readString()

                case 34:
                    latitude = try codedInputStream.readString()

                case 42:
                    androidName = try codedInputStream.readString()

                case 50:
                    androidBrand = try codedInputStream.readString()

                case 58:
                    androidModel = try codedInputStream.readString()

                case 66:
                    versionRelease = try codedInputStream.readString()

                case 74:
                    manufacturer = try codedInputStream.readString()

                case 82:
                    versionLib = try codedInputStream.readString()

                case 88:
                    versionCode = try codedInputStream.readInt32()

                case 96:
                    versionOs = try codedInputStream.readInt32()

                case 106:
                    androidFingerPrint = try codedInputStream.readString()

                case 114:
                    userAgent = try codedInputStream.readString()

                case 122:
                    linkPlayStore = try codedInputStream.readString()

                case 130:
                    typeCategory = try codedInputStream.readString()

                case 138:
                    imei = try codedInputStream.readString()

                case 146:
                    softwareVersion = try codedInputStream.readString()

                case 154:
                    languageApp = try codedInputStream.readString()

                case 162:
                    userId = try codedInputStream.readString()

                case 168:
                    acc = try codedInputStream.readUInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> MobileInfo.Builder {
            let resultDecodedBuilder = MobileInfo.Builder()
            if let jsonValueDeviceId = jsonMap["deviceId"] as? String {
                resultDecodedBuilder.deviceId = jsonValueDeviceId
            }
            if let jsonValuePlatform = jsonMap["platform"] as? String {
                resultDecodedBuilder.platform = jsonValuePlatform
            }
            if let jsonValueLongitude = jsonMap["longitude"] as? String {
                resultDecodedBuilder.longitude = jsonValueLongitude
            }
            if let jsonValueLatitude = jsonMap["latitude"] as? String {
                resultDecodedBuilder.latitude = jsonValueLatitude
            }
            if let jsonValueAndroidName = jsonMap["androidName"] as? String {
                resultDecodedBuilder.androidName = jsonValueAndroidName
            }
            if let jsonValueAndroidBrand = jsonMap["androidBrand"] as? String {
                resultDecodedBuilder.androidBrand = jsonValueAndroidBrand
            }
            if let jsonValueAndroidModel = jsonMap["androidModel"] as? String {
                resultDecodedBuilder.androidModel = jsonValueAndroidModel
            }
            if let jsonValueVersionRelease = jsonMap["versionRelease"] as? String {
                resultDecodedBuilder.versionRelease = jsonValueVersionRelease
            }
            if let jsonValueManufacturer = jsonMap["manufacturer"] as? String {
                resultDecodedBuilder.manufacturer = jsonValueManufacturer
            }
            if let jsonValueVersionLib = jsonMap["versionLib"] as? String {
                resultDecodedBuilder.versionLib = jsonValueVersionLib
            }
            if let jsonValueVersionCode = jsonMap["versionCode"] as? Int {
                resultDecodedBuilder.versionCode = Int32(jsonValueVersionCode)
            } else if let jsonValueVersionCode = jsonMap["versionCode"] as? String {
                resultDecodedBuilder.versionCode = Int32(jsonValueVersionCode)!
            }
            if let jsonValueVersionOs = jsonMap["versionOS"] as? Int {
                resultDecodedBuilder.versionOs = Int32(jsonValueVersionOs)
            } else if let jsonValueVersionOs = jsonMap["versionOS"] as? String {
                resultDecodedBuilder.versionOs = Int32(jsonValueVersionOs)!
            }
            if let jsonValueAndroidFingerPrint = jsonMap["androidFingerPrint"] as? String {
                resultDecodedBuilder.androidFingerPrint = jsonValueAndroidFingerPrint
            }
            if let jsonValueUserAgent = jsonMap["userAgent"] as? String {
                resultDecodedBuilder.userAgent = jsonValueUserAgent
            }
            if let jsonValueLinkPlayStore = jsonMap["linkPlayStore"] as? String {
                resultDecodedBuilder.linkPlayStore = jsonValueLinkPlayStore
            }
            if let jsonValueTypeCategory = jsonMap["typeCategory"] as? String {
                resultDecodedBuilder.typeCategory = jsonValueTypeCategory
            }
            if let jsonValueImei = jsonMap["imei"] as? String {
                resultDecodedBuilder.imei = jsonValueImei
            }
            if let jsonValueSoftwareVersion = jsonMap["softwareVersion"] as? String {
                resultDecodedBuilder.softwareVersion = jsonValueSoftwareVersion
            }
            if let jsonValueLanguageApp = jsonMap["languageApp"] as? String {
                resultDecodedBuilder.languageApp = jsonValueLanguageApp
            }
            if let jsonValueUserId = jsonMap["userId"] as? String {
                resultDecodedBuilder.userId = jsonValueUserId
            }
            if let jsonValueAcc = jsonMap["acc"] as? UInt {
                resultDecodedBuilder.acc = UInt32(jsonValueAcc)
            } else if let jsonValueAcc = jsonMap["acc"] as? String {
                resultDecodedBuilder.acc = UInt32(jsonValueAcc)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> MobileInfo.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try MobileInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Track: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Track> {
        var mergedArray = Array<Track>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Track? {
        return try Track.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Track {
        return try Track.Builder().mergeFrom(data: data, extensionRegistry:PackageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Track {
        return try Track.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Track {
        return try Track.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Track {
        return try Track.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Track {
        return try Track.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Track {
        return try Track.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "acc": return self.acc
        case "nameApp": return self.nameApp
        case "deviceIp": return self.deviceIp
        case "pageViews": return self.pageViews
        case "typeConnection": return self.typeConnection
        default: return nil
        }
    }
}
extension Track.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Track
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "acc": return self.acc
            case "nameApp": return self.nameApp
            case "deviceIp": return self.deviceIp
            case "pageViews": return self.pageViews
            case "typeConnection": return self.typeConnection
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "acc":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.acc = newSubscriptValue
            case "nameApp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nameApp = newSubscriptValue
            case "deviceIp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceIp = newSubscriptValue
            case "pageViews":
                guard let newSubscriptValue = newSubscriptValue as? Array<PageView> else {
                    return
                }
                self.pageViews = newSubscriptValue
            case "typeConnection":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.typeConnection = newSubscriptValue
            default: return
            }
        }
    }
}
extension PageView: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PageView> {
        var mergedArray = Array<PageView>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PageView? {
        return try PageView.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PageView {
        return try PageView.Builder().mergeFrom(data: data, extensionRegistry:PackageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PageView {
        return try PageView.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PageView {
        return try PageView.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PageView {
        return try PageView.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PageView {
        return try PageView.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PageView {
        return try PageView.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "activity": return self.activity
        case "dateTime": return self.dateTime
        case "titlePage": return self.titlePage
        case "callPage": return self.callPage
        default: return nil
        }
    }
}
extension PageView.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PageView
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "activity": return self.activity
            case "dateTime": return self.dateTime
            case "titlePage": return self.titlePage
            case "callPage": return self.callPage
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "activity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.activity = newSubscriptValue
            case "dateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.dateTime = newSubscriptValue
            case "titlePage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.titlePage = newSubscriptValue
            case "callPage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.callPage = newSubscriptValue
            default: return
            }
        }
    }
}
extension MobileInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<MobileInfo> {
        var mergedArray = Array<MobileInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> MobileInfo? {
        return try MobileInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> MobileInfo {
        return try MobileInfo.Builder().mergeFrom(data: data, extensionRegistry:PackageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> MobileInfo {
        return try MobileInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> MobileInfo {
        return try MobileInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> MobileInfo {
        return try MobileInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> MobileInfo {
        return try MobileInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MobileInfo {
        return try MobileInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceId": return self.deviceId
        case "platform": return self.platform
        case "longitude": return self.longitude
        case "latitude": return self.latitude
        case "androidName": return self.androidName
        case "androidBrand": return self.androidBrand
        case "androidModel": return self.androidModel
        case "versionRelease": return self.versionRelease
        case "manufacturer": return self.manufacturer
        case "versionLib": return self.versionLib
        case "versionCode": return self.versionCode
        case "versionOs": return self.versionOs
        case "androidFingerPrint": return self.androidFingerPrint
        case "userAgent": return self.userAgent
        case "linkPlayStore": return self.linkPlayStore
        case "typeCategory": return self.typeCategory
        case "imei": return self.imei
        case "softwareVersion": return self.softwareVersion
        case "languageApp": return self.languageApp
        case "userId": return self.userId
        case "acc": return self.acc
        default: return nil
        }
    }
}
extension MobileInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = MobileInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceId": return self.deviceId
            case "platform": return self.platform
            case "longitude": return self.longitude
            case "latitude": return self.latitude
            case "androidName": return self.androidName
            case "androidBrand": return self.androidBrand
            case "androidModel": return self.androidModel
            case "versionRelease": return self.versionRelease
            case "manufacturer": return self.manufacturer
            case "versionLib": return self.versionLib
            case "versionCode": return self.versionCode
            case "versionOs": return self.versionOs
            case "androidFingerPrint": return self.androidFingerPrint
            case "userAgent": return self.userAgent
            case "linkPlayStore": return self.linkPlayStore
            case "typeCategory": return self.typeCategory
            case "imei": return self.imei
            case "softwareVersion": return self.softwareVersion
            case "languageApp": return self.languageApp
            case "userId": return self.userId
            case "acc": return self.acc
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceId = newSubscriptValue
            case "platform":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.platform = newSubscriptValue
            case "longitude":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.longitude = newSubscriptValue
            case "latitude":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.latitude = newSubscriptValue
            case "androidName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.androidName = newSubscriptValue
            case "androidBrand":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.androidBrand = newSubscriptValue
            case "androidModel":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.androidModel = newSubscriptValue
            case "versionRelease":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.versionRelease = newSubscriptValue
            case "manufacturer":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.manufacturer = newSubscriptValue
            case "versionLib":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.versionLib = newSubscriptValue
            case "versionCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.versionCode = newSubscriptValue
            case "versionOs":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.versionOs = newSubscriptValue
            case "androidFingerPrint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.androidFingerPrint = newSubscriptValue
            case "userAgent":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userAgent = newSubscriptValue
            case "linkPlayStore":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.linkPlayStore = newSubscriptValue
            case "typeCategory":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.typeCategory = newSubscriptValue
            case "imei":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.imei = newSubscriptValue
            case "softwareVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.softwareVersion = newSubscriptValue
            case "languageApp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.languageApp = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "acc":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.acc = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
